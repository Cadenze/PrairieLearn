<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/databaseDescribe.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/databaseDescribe.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const ERR = require('async-stacktrace');
const async = require('async');
const pgArray = require('pg').types.arrayParser;
const colors = require('colors');
const _ = require('lodash');

const sqldb = require('@prairielearn/prairielib/sql-db');
const sqlLoader = require('@prairielearn/prairielib/sql-loader');
const sql = sqlLoader.loadSqlEquiv(__filename);

module.exports = {};

/**
 * will produce a description of a given database's schema. This will include
 * information about tables, enums, contraints, indices, etc.
 *
 * This functions accepts an 'options' object with various options that determine
 * how the function will run. The following properties are available on the
 * 'options' object:
 *
 * databaseName [REQUIRED]: the name of the database to describe
 * outputFormat [default: 'string']: determines how the description is formatted
 * coloredOutput [default: false]: if the output should be colored for better readability
 *
 * @param  {Object}   options  Options for this function
 * @param  {Function} callback Will receive results of an error when complete
 */
module.exports.describe = function(options, callback) {
    if (!options) return callback(new Error('options must not be null'));
    if (!options.databaseName) return callback(new Error('you must specify a database name with databaseName'));
    if (options.outputFormat &amp;&amp; !(options.outputFormat == 'string' || options.outputFormat == 'object')) {
        return callback(new Error(`'${options.outputFormat}' is not a valid output format`));
    }

    var tables;
    var ignoreColumns = {};

    var output = {
        tables: {},
        enums: {},
    };

    var formatText = function(text, formatter) {
        if (options.coloredOutput) {
            return formatter(text);
        }
        return text;
    };

    async.series([
        (callback) => {
            // Connect to the database
            var pgConfig = {
                user: options.postgresqlUser || 'postgres',
                database: options.databaseName,
                host: options.postgresqlHost || 'localhost',
                max: 10,
                idleTimeoutMillis: 30000,
            };
            var idleErrorHandler = function(err) {
                throw Error('idle client error', err);
            };
            sqldb.init(pgConfig, idleErrorHandler, function(err) {
                if (ERR(err, callback)) return;
                callback(null);
            });
        },
        (callback) => {
            // Get the names of the tables
            sqldb.query(sql.get_tables, [], (err, results) => {
                if (ERR(err, callback)) return;
                tables = results.rows;

                // Filter out ignored tables
                if (options.ignoreTables &amp;&amp; _.isArray(options.ignoreTables)) {
                    tables = _.filter(tables, table => options.ignoreTables.indexOf(table.name) == -1);
                }

                // Initialize output with names of tables
                if (options.outputFormat === 'string') {
                    tables.forEach((table) => output.tables[table.name] = '');
                } else {
                    tables.forEach((table) => output.tables[table.name] = {});
                }

                callback(null);
            });
        },
        (callback) => {
            // Transform ignored columns into a map from table names to arrays
            // of column names
            if (options.ignoreColumns &amp;&amp; _.isArray(options.ignoreColumns)) {
                ignoreColumns = _.filter(options.ignoreColumns, ignore => {
                    return /^[^\s.]*\.[^\s.]*$/.test(ignore);
                });
                ignoreColumns = _.reduce(ignoreColumns, (result, value) => {
                    var res = /^(([^\s.]*)\.([^\s.]*))$/.exec(value);
                    var table = res[2];
                    var column = res[3];
                    (result[table] || (result[table] = [])).push(column);
                    return result;
                }, {});
            }
            callback(null);
        },
        (callback) => {
            // Get column info for each table
            async.each(tables, (table, callback) => {
                async.series([
                    (callback) => {
                        const params = {
                            oid: table.oid,
                        };
                        sqldb.query(sql.get_columns_for_table, params, (err, results) => {
                            if (ERR(err, callback)) return;

                            const rows = _.filter(results.rows, row => {
                                return (ignoreColumns[table.name] || []).indexOf(row.name) == -1;
                            });

                            if (rows.length == 0) {
                                return callback(null);
                            }

                            // Transform table info into a string, if needed
                            if (options.outputFormat === 'string') {
                                output.tables[table.name] += formatText('columns\n', colors.underline);
                                output.tables[table.name] += rows.map((row) => {
                                    var rowText = formatText(`    ${row.name}`, colors.bold);
                                    rowText += ':' + formatText(` ${row.type}`, colors.green);
                                    if (row.notnull) {
                                        rowText += formatText(' not null', colors.gray);
                                    }
                                    if (row.default) {
                                        rowText += formatText(` default ${row.default}`, colors.gray);
                                    }
                                    return rowText;
                                }).join('\n');
                            } else {
                                output.tables[table.name].columns = rows;
                            }
                            callback(null);
                        });
                    },
                    (callback) => {
                        const params = {
                            oid: table.oid,
                        };
                        sqldb.query(sql.get_indexes_for_table, params, (err, results) => {
                            if (ERR(err, callback)) return;

                            if (results.rows.length == 0) {
                                return callback(null);
                            }

                            if (options.outputFormat === 'string') {
                                if (output.tables[table.name].length != 0) {
                                    output.tables[table.name] += '\n\n';
                                }
                                output.tables[table.name] += formatText('indexes\n', colors.underline);
                                output.tables[table.name] += results.rows.map((row) => {
                                    const using = row.indexdef.substring(row.indexdef.indexOf('USING '));
                                    var rowText = formatText(`    ${row.name}`, colors.bold) + ':';
                                    // Primary indexes are implicitly unique, so we don't need to
                                    // capture that explicitly.
                                    if (row.isunique &amp;&amp; !row.isprimary) {
                                        if (!row.constraintdef || row.constraintdef.indexOf('UNIQUE') === -1) {
                                            // Some unique indexes don't incldue the UNIQUE constraint
                                            // as part of the constraint definition, so we need to capture
                                            // that manually.
                                            rowText += formatText(` UNIQUE`, colors.green);
                                        }
                                    }
                                    rowText += row.constraintdef ? formatText(` ${row.constraintdef}`, colors.green) : '';
                                    rowText += using ? formatText(` ${using}`, colors.green) : '';
                                    return rowText;
                                }).join('\n');
                            } else {
                                output.tables[table.name].indexes = results.rows;
                            }
                            callback(null);
                        });
                    },
                    (callback) => {
                        const params = {
                            oid: table.oid,
                        };
                        sqldb.query(sql.get_foreign_key_constraints_for_table, params, (err, results) => {
                            if (ERR(err, callback)) return;

                            if (results.rows.length == 0) {
                                return callback(null);
                            }

                            if (options.outputFormat === 'string') {
                                if (output.tables[table.name].length != 0) {
                                    output.tables[table.name] += '\n\n';
                                }
                                output.tables[table.name] += formatText('foreign-key constraints\n', colors.underline);
                                output.tables[table.name] += results.rows.map((row) => {
                                    var rowText = formatText(`    ${row.name}:`, colors.bold);
                                    rowText += formatText(` ${row.def}`, colors.green);
                                    return rowText;
                                }).join('\n');
                            } else {
                                output.tables[table.name].foreignKeyConstraints = results.rows;
                            }
                            callback(null);
                        });
                    },
                    (callback) => {
                        const params = {
                            oid: table.oid,
                        };
                        sqldb.query(sql.get_references_for_table, params, (err, results) => {
                            if (ERR(err, callback)) return;

                            // Filter out references from ignored tables
                            let rows = results.rows;
                            if (options.ignoreTables &amp;&amp; _.isArray(options.ignoreTables)) {
                                rows = _.filter(results.rows, row => {
                                    return options.ignoreTables.indexOf(row.table) == -1;
                                });
                            }

                            if (rows.length == 0) {
                                return callback(null);
                            }

                            if (options.outputFormat === 'string') {
                                if (output.tables[table.name].length != 0) {
                                    output.tables[table.name] += '\n\n';
                                }
                                output.tables[table.name] += formatText('referenced by\n', colors.underline);
                                output.tables[table.name] += rows.map((row) => {
                                    var rowText = formatText(`    ${row.table}:`, colors.bold);
                                    rowText += formatText(` ${row.condef}`, colors.green);
                                    return rowText;
                                }).join('\n');
                            } else {
                                output.tables[table.name].references = rows;
                            }
                            callback(null);
                        });
                    },
                ], (err) => {
                    if (ERR(err, callback)) return;
                    callback(null);
                });
            }, (err) => {
                if (ERR(err, callback)) return;
                callback(null);
            });
        },
        (callback) => {
            // Get all enums
            sqldb.query(sql.get_enums, [], (err, results) => {
                if (ERR(err, callback)) return;

                // Filter ignored enums
                let rows = results.rows;
                if (options.ignoreEnums &amp;&amp; _.isArray(options.ignoreEnums)) {
                    rows = _.filter(results.rows, row => {
                        return options.ignoreEnums.indexOf(row.name) == -1;
                    });
                }

                if (rows.length == 0) {
                    return callback(null);
                }

                rows.forEach((row) => {
                    if (options.outputFormat == 'string') {
                        const values = pgArray.create(row.values, String).parse();
                        output.enums[row.name] = formatText(values.join(', '), colors.gray);
                    } else {
                        output.enums[row.name] = pgArray.create(row.values, String).parse();
                    }
                });

                callback(null);
            });
        },
        (callback) => {
            // We need to tack on a newline to everything if we're in string mode
            if (options.outputFormat == 'string') {
                output.tables = _.mapValues(output.tables, item => item + '\n');
                output.enums = _.mapValues(output.enums, item => item + '\n');
            }
            callback(null);
        },
        (callback) => {
            sqldb.close((err) => {
                if (ERR(err, callback)) return;
                callback(null);
            });
        },
    ], (err) => {
        if (ERR(err, callback)) return;
        callback(null, output);
    });
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-assessment.html">assessment</a></li><li><a href="module-question.html">question</a></li><li><a href="module-question-servers.html">question-servers</a></li></ul><h3>Classes</h3><ul><li><a href="LocalCache.html">LocalCache</a></li><li><a href="LocalLock.html">LocalLock</a></li><li><a href="module-question-NoSubmissionError.html">NoSubmissionError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_generateAllChunksForCourseListWithJobSequence">_generateAllChunksForCourseListWithJobSequence</a></li><li><a href="global.html#_generateAllChunksForCourseWithJob">_generateAllChunksForCourseWithJob</a></li><li><a href="global.html#_getLock">_getLock</a></li><li><a href="global.html#_syncDiskToSqlWithLock">_syncDiskToSqlWithLock</a></li><li><a href="global.html#_updateScoreWithClient">_updateScoreWithClient</a></li><li><a href="global.html#addError">addError</a></li><li><a href="global.html#addErrors">addErrors</a></li><li><a href="global.html#addWarning">addWarning</a></li><li><a href="global.html#addWarnings">addWarnings</a></li><li><a href="global.html#assetPath">assetPath</a></li><li><a href="global.html#buildDirectory">buildDirectory</a></li><li><a href="global.html#checkAllowAccessDates">checkAllowAccessDates</a></li><li><a href="global.html#checkDuplicateUUIDs">checkDuplicateUUIDs</a></li><li><a href="global.html#close">close</a></li><li><a href="global.html#courseDataHasErrors">courseDataHasErrors</a></li><li><a href="global.html#courseDataHasErrorsOrWarnings">courseDataHasErrorsOrWarnings</a></li><li><a href="global.html#createAndUploadChunks">createAndUploadChunks</a></li><li><a href="global.html#delete">delete</a></li><li><a href="global.html#deleteFromS3Async">deleteFromS3Async</a></li><li><a href="global.html#describe">describe</a></li><li><a href="global.html#downloadFromS3Async">downloadFromS3Async</a></li><li><a href="global.html#ensureChunk">ensureChunk</a></li><li><a href="global.html#ensureChunksForCourseAsync">ensureChunksForCourseAsync</a></li><li><a href="global.html#ERR">ERR</a></li><li><a href="global.html#extractAndSaveCSRFToken">extractAndSaveCSRFToken</a></li><li><a href="global.html#extractAndSaveVariantId">extractAndSaveVariantId</a></li><li><a href="global.html#fetchCheerio">fetchCheerio</a></li><li><a href="global.html#generateAllChunksForCourseList">generateAllChunksForCourseList</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAllChunksForCourse">getAllChunksForCourse</a></li><li><a href="global.html#getChunksDirectoriesForCourseId">getChunksDirectoriesForCourseId</a></li><li><a href="global.html#getDetailsForFile">getDetailsForFile</a></li><li><a href="global.html#getDevHostJobDirectory">getDevHostJobDirectory</a></li><li><a href="global.html#getDevJobDirectory">getDevJobDirectory</a></li><li><a href="global.html#getErrorsAndWarningsForFilePath">getErrorsAndWarningsForFilePath</a></li><li><a href="global.html#getFromS3Async">getFromS3Async</a></li><li><a href="global.html#getJobDirectory">getJobDirectory</a></li><li><a href="global.html#getJobSequenceWithFormattedOutput">getJobSequenceWithFormattedOutput</a></li><li><a href="global.html#getOrUpdateCourseCommitHash">getOrUpdateCourseCommitHash</a></li><li><a href="global.html#getRuntimeDirectoryForCourse">getRuntimeDirectoryForCourse</a></li><li><a href="global.html#getStream">getStream</a></li><li><a href="global.html#getTemplateQuestionIdsAsync">getTemplateQuestionIdsAsync</a></li><li><a href="global.html#hasErrors">hasErrors</a></li><li><a href="global.html#hasErrorsOrWarnings">hasErrorsOrWarnings</a></li><li><a href="global.html#hasUuid">hasUuid</a></li><li><a href="global.html#hasWarnings">hasWarnings</a></li><li><a href="global.html#identifyChangedFiles">identifyChangedFiles</a></li><li><a href="global.html#identifyChunksFromChangedFiles">identifyChunksFromChangedFiles</a></li><li><a href="global.html#identifyChunksToGenerate">identifyChunksToGenerate</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#loadAndValidateJson">loadAndValidateJson</a></li><li><a href="global.html#loadAssessments">loadAssessments</a></li><li><a href="global.html#loadConfigSecrets">loadConfigSecrets</a></li><li><a href="global.html#loadCourseInfo">loadCourseInfo</a></li><li><a href="global.html#loadCourseInstances">loadCourseInstances</a></li><li><a href="global.html#loadFullCourse">loadFullCourse</a></li><li><a href="global.html#loadFullCourseNew">loadFullCourseNew</a></li><li><a href="global.html#loadInfoFile">loadInfoFile</a></li><li><a href="global.html#loadInfoForDirectory">loadInfoForDirectory</a></li><li><a href="global.html#loadQuestions">loadQuestions</a></li><li><a href="global.html#makeError">makeError</a></li><li><a href="global.html#makeGradingResult">makeGradingResult</a></li><li><a href="global.html#makeWarning">makeWarning</a></li><li><a href="global.html#nodeModulesAssetPath">nodeModulesAssetPath</a></li><li><a href="global.html#nonblockingStringify">nonblockingStringify</a></li><li><a href="global.html#pendingChunksMap">pendingChunksMap</a></li><li><a href="global.html#RandomGenerator">RandomGenerator</a></li><li><a href="global.html#readInfoJSON">readInfoJSON</a></li><li><a href="global.html#readJSON">readJSON</a></li><li><a href="global.html#readJSONSyncOrDie">readJSONSyncOrDie</a></li><li><a href="global.html#releaseLock">releaseLock</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#sendCourseRequestMessage">sendCourseRequestMessage</a></li><li><a href="global.html#sendProctorMessage">sendProctorMessage</a></li><li><a href="global.html#sendSlackAlmaMessage">sendSlackAlmaMessage</a></li><li><a href="global.html#Stringifier">Stringifier</a></li><li><a href="global.html#stringifyErrors">stringifyErrors</a></li><li><a href="global.html#stringifyWarnings">stringifyWarnings</a></li><li><a href="global.html#syncDiskToSql">syncDiskToSql</a></li><li><a href="global.html#syncDiskToSqlWithLock">syncDiskToSqlWithLock</a></li><li><a href="global.html#syncOrCreateDiskToSql">syncOrCreateDiskToSql</a></li><li><a href="global.html#tryLock">tryLock</a></li><li><a href="global.html#updateChunksForCourse">updateChunksForCourse</a></li><li><a href="global.html#updateCourseCommitHash">updateCourseCommitHash</a></li><li><a href="global.html#updateScore">updateScore</a></li><li><a href="global.html#upload">upload</a></li><li><a href="global.html#uploadDirectoryToS3Async">uploadDirectoryToS3Async</a></li><li><a href="global.html#uploadToS3Async">uploadToS3Async</a></li><li><a href="global.html#validateAssessment">validateAssessment</a></li><li><a href="global.html#validateCourseInstance">validateCourseInstance</a></li><li><a href="global.html#validateJSON">validateJSON</a></li><li><a href="global.html#validateJSONAsync">validateJSONAsync</a></li><li><a href="global.html#validateOptions">validateOptions</a></li><li><a href="global.html#validateQuestion">validateQuestion</a></li><li><a href="global.html#visitMathBlock">visitMathBlock</a></li><li><a href="global.html#waitLock">waitLock</a></li><li><a href="global.html#writeErrorsAndWarningsForCourseData">writeErrorsAndWarningsForCourseData</a></li><li><a href="global.html#writeErrorsAndWarningsForInfoFileIfNeeded">writeErrorsAndWarningsForInfoFileIfNeeded</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Jun 02 2021 10:45:55 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
