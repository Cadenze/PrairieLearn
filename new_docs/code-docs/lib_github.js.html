<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/github.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/github.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Octokit } = require('@octokit/rest');
const { v4: uuidv4 } = require('uuid');
const _ = require('lodash');

const ERR = require('async-stacktrace');
const config = require('./config');
const logger = require('./logger');
const serverJobs = require('./server-jobs');
const courseUtil = require('./courseUtil');
const syncFromDisk = require('../sync/syncFromDisk');
const opsbot = require('./opsbot');
const chunks = require('./chunks');

const sqldb = require('@prairielearn/prairielib/sql-db');
const sqlLoader = require('@prairielearn/prairielib/sql-loader');
const sql = sqlLoader.loadSqlEquiv(__filename);

/*
  Required configuration options to get this working:
  - config.githubClientToken
  - config.githubCourseOwner
  - config.githubCourseTemplate
  - config.githubMachineTeam
*/

module.exports = {
    /**
     * Creates an octokit client from the client token specified in the config]
     * @returns octokit client that can be passed into the other functions in this module.
     */
    getGithubClient: function() {
        if (config.githubClientToken === null) {
            return null;
        }
        return new Octokit({ auth: config.githubClientToken });
    },

    _waitAsync: function(millis) {
        return new Promise((res, _rej) => {
            setTimeout(res, millis);
        });
    },

    /**
     * Slugs a course shortname into a GitHub repository name.
     * @param short_name Course shortname
     */
    reponameFromShortname(short_name) {
        return 'pl-' + short_name.replace(' ', '').toLowerCase();
    },

    /**
     * Creates a new repository from a given template.
     * @param client Octokit client
     * @param repo Name of the new repo to create
     * @param template Name of the template to use
     */
    createRepoFromTemplateAsync: async function(client, repo, template) {
        await client.repos.createUsingTemplate({
            template_owner: config.githubCourseOwner,
            template_repo: template,
            owner: config.githubCourseOwner,
            name: repo,
            private: true,
        });

        /* The above call will complete before the repo itself is actually ready to use,
           so poll for a bit until all the files are finally copied in */
        let repo_up = false;
        const poll_time_ms = 100;
        while (!repo_up) {
            try {
                /* If the repo is not ready yet, this will fail with "repo is empty" */
                await client.repos.getContent({
                    owner: config.githubCourseOwner,
                    repo: repo,
                });
                repo_up = true;
            } catch (err) {
                logger.debug(`${repo} is not ready yet, polling again in ${poll_time_ms} ms`);
            }

            if (!repo_up) {
                await module.exports._waitAsync(poll_time_ms);
            }
        }
    },

    /**
     * Pulls the contents of a file from a repository.
     * @param client Octokit client
     * @param repo Repository to get file contents from
     * @param path Path to the file, relative from the root of the repository.
     * @returns An object representing the file data.  Raw contents are stored in the 'contents' key,
     * while the file's SHA is stored in 'sha' (this is needed if you want to update the contents later)
     */
    getFileFromRepoAsync: async function(client, repo, path) {
        const file = await client.repos.getContent({
            owner: config.githubCourseOwner,
            repo: repo,
            path: path,
        });
        return {
            sha: file.data.sha,
            contents: (Buffer.from(file.data.content, file.data.encoding)).toString('ascii'),
        };
    },

    /**
     * Updates a file's contents in a repository.
     * @param client Octokit client
     * @param repo Repository to set file contents in
     * @param path Path to the file, relative from the root of the repository.
     * @param contents Raw contents of the file, stored as a string.
     * @param sha The file's SHA that is being updated (this is returned in getFileFromRepoAsync).
     */
    putFileToRepoAsync: async function(client, repo, path, contents, sha) {
        await client.repos.createOrUpdateFileContents({
            owner: config.githubCourseOwner,
            repo: repo,
            path: path,
            message: `Update ${path}`,
            content: Buffer.from(contents + '\n', 'ascii').toString('base64'), /* Add ending newline */
            sha: sha,
        });
    },

    /**
     * Add a team to a specific repository.
     * @param client Octokit client
     * @param repo Repository to update
     * @param team Team to add
     * @param permission String permission to give to the team, can be one of the following:
     *  - pull
     *  - push
     *  - admin
     *  - maintain
     *  - triage
     */
    addTeamToRepoAsync: async function(client, repo, team, permission) {
        await client.teams.addOrUpdateRepoPermissionsInOrg({
            owner: config.githubCourseOwner,
            org: config.githubCourseOwner,
            repo: repo,
            team_slug: team,
            permission: permission,
        });
    },

    /**
     * Invites a user to a specific repository.
     * @param client Octokit client
     * @param repo Repository to update
     * @param username Username to add
     * @param permission String permission to give to the user, can be one of the following:
     *  - pull
     *  - push
     *  - admin
     *  - maintain
     *  - triage
     */
    addUserToRepoAsync: async function(client, repo, username, permission) {
        await client.repos.addCollaborator({
            owner: config.githubCourseOwner,
            repo: repo,
            username: username,
            permission: permission,
        });
    },

    _runJobAsync: function(options, job_sequence_id, user_id, func) {
        return new Promise((resolve, reject) => {
            options = _.defaults({
                user_id: user_id,
                authn_user_id: user_id,
                job_sequence_id,
                on_success: resolve,
                on_error: reject,
            }, options);

            serverJobs.createJob(options, function(err, job) {
                if (err) {
                    logger.error('Error in createJob()', err);
                    serverJobs.failJobSequence(job_sequence_id);
                    reject(err);
                    return;
                }
                func(job)
                    .then(() => { job.succeed(); resolve(); })
                    .catch((err) => {
                        job.fail(err);
                        /* Give a descriptive error message */
                        const err_msg =
                              `Failure while running job "${job.options.description}":\n` +
                              `${err}`;
                        reject(new Error(err_msg));
                    });
            });
        });
    },

    _runJobCommandAsync: function(options, job_sequence_id, user_id) {
        return new Promise((resolve, reject) => {
            options = _.defaults({
                user_id: user_id,
                authn_user_id: user_id,
                job_sequence_id,
                on_success: resolve,
            }, options);

            serverJobs.spawnJob(options, (err, job) => {
                if (ERR(err, reject)) return;
                job.options.on_error = () => {
                    /* Give a descriptive error message */
                    const err_msg =
                          `Failure while running job "${options.description}":\n` +
                          `${job.output}`;
                    reject(new Error(err_msg));
                };
            });
        });
    },

    /**
     * Starts a new server job to create a course GitHub repo, add it to the database, and then sync it locally.
     * @params options Options for creating the course, should contain the following keys:
     * - short_name
     * - title
     * - institution_id
     * - display_timezone
     * - path
     * - repo_short_name
     * - github_user
     * - course_request_id
     * @params authn_user Authenticated user that is creating the course.
     * @params callback Callback to run once the job sequence is created.  Will contain the sequence id as an argument.
     */
    createCourseRepoJob: function(options, authn_user, callback) {
        const worker_function = async (job_sequence_id) => {
            const client = module.exports.getGithubClient();
            if (client === null) {
                /* If we are running locally and don't have a client, then just exit early */
                await module.exports._runJobAsync({ 'type': 'exit_early', 'description': 'Nothing to do, exiting...', last_in_sequence: true }, job_sequence_id, authn_user.user_id, async () => { return; });
                return;
            }

            /* As a debug step, show the course information given to us since the info can be changed by an admin before the job is run */
            await module.exports._runJobAsync({'type': 'info', 'description': 'Show course information'}, job_sequence_id, authn_user.user_id, async (job) => {
                job.info(`Creating course ${options.short_name}`);
                job.info(JSON.stringify(options, null, 4));
            });

            /* Create base github repo from template */
            await module.exports._runJobAsync({'type': 'create_repo', 'description': 'Creating repository from template'}, job_sequence_id, authn_user.user_id, async (job) => {
                await module.exports.createRepoFromTemplateAsync(client, options.repo_short_name, config.githubCourseTemplate);
                job.info(`Created repository ${options.repo_short_name}`);

                /* Find main branch (which is the only branch in the new repo), output of this is array of objects following:
                   https://docs.github.com/en/rest/reference/repos#list-branches */
                const branches = (await client.repos.listBranches({
                    owner: config.githubCourseOwner,
                    repo: options.repo_short_name,
                })).data;
                if (branches.length != 1) {
                    throw new Error(`New repo has ${branches.length} branches, expected one.`);
                }
                options.branch = branches[0].name || config.githubMainBranch;
                job.info(`Main branch for new repository: "${options.branch}"`);
            });

            /* Update the infoCourse.json file by grabbing the original and JSON editing it. */
            await module.exports._runJobAsync({'type': 'update_info_course', 'description': 'Updating infoCourse.json'}, job_sequence_id, authn_user.user_id, async (job) => {
                let {sha: sha, contents: courseInfo} = await module.exports.getFileFromRepoAsync(client, options.repo_short_name, 'infoCourse.json');
                job.info(`Loaded infoCourse.json file (SHA ${sha})`);

                courseInfo = JSON.parse(courseInfo);
                courseInfo.uuid = uuidv4();
                courseInfo.name = options.short_name;
                courseInfo.title = options.title;
                courseInfo = JSON.stringify(courseInfo, null, 4);

                job.verbose('New infoCourse.json file:');
                job.verbose(courseInfo);

                await module.exports.putFileToRepoAsync(client, options.repo_short_name, 'infoCourse.json', courseInfo, sha);
                job.info('Uploaded new infoCourse.json file');
            });

            /* Add machine and instructor to the repo */
            await module.exports._runJobAsync({'type': 'add_machine', 'description': 'Adding machine team to repo'}, job_sequence_id, authn_user.user_id, async (job) => {
                await module.exports.addTeamToRepoAsync(client, options.repo_short_name, config.githubMachineTeam, 'admin');
                job.info(`Added team ${config.githubMachineTeam} as administrator of repo ${options.repo_short_name}`);
            });
            if (options.github_user) {
                await module.exports._runJobAsync({'type': 'add_instructor', 'description': 'Adding instructor to repository'}, job_sequence_id, authn_user.user_id, async (job) => {
                    try {
                        await module.exports.addUserToRepoAsync(client, options.repo_short_name, options.github_user, 'admin');
                        job.info(`Added user ${options.github_user} as administrator of repo ${options.repo_short_name}`);
                    } catch (err) {
                        job.error(`Could not add user "${options.github_user}": ${err}`);
                    }
                });
            }

            /* Insert the course into the courses table */
            let inserted_course;
            await module.exports._runJobAsync({'type': 'update_courses', 'description': 'Adding course to database'}, job_sequence_id, authn_user.user_id, async (job) => {
                const sql_params = [
                    options.institution_id,
                    options.short_name,
                    options.title,
                    options.display_timezone,
                    options.path,
                    `git@github.com:${config.githubCourseOwner}/${options.repo_short_name}.git`,
                    options.branch,
                    authn_user.user_id,
                ];
                inserted_course = (await sqldb.callAsync('courses_insert', sql_params)).rows[0];
                job.verbose('Inserted course into database:');
                job.verbose(JSON.stringify(inserted_course, null, 4));
            });

            /* Give the owner required permissions */
            await module.exports._runJobAsync({'type': 'update_', 'description': 'Giving user owner permission'}, job_sequence_id, authn_user.user_id, async () => {
                const sql_params = {
                    'course_id': inserted_course.id,
                    'course_request_id': options.course_request_id,
                };
                await sqldb.queryOneRowAsync(sql.set_course_owner_permission, sql_params);
            });

            /* Automatically sync the new course.  This part is shamelessly stolen from pages/shared/syncHelpers.js */
            const git_env = process.env;
            if (config.gitSshCommand != null) {
                git_env.GIT_SSH_COMMAND = config.gitSshCommand;
            }
            await module.exports._runJobCommandAsync({
                type: 'clone_from_git',
                description: 'Clone from remote git repository',
                command: 'git',
                arguments: ['clone', inserted_course.repository, inserted_course.path],
                env: git_env,
            }, job_sequence_id, authn_user.user_id);
            await module.exports._runJobAsync({'type': 'update_commit_hash', 'description': 'Update course commit hash'}, job_sequence_id, authn_user.user_id, async () => {
                await courseUtil.updateCourseCommitHashAsync(inserted_course);
            });
            let sync_result;
            await module.exports._runJobAsync({
                'type': 'sync_from_disk',
                'description': 'Sync git repository to database',
                last_in_sequence: !config.chunksGenerator,
            }, job_sequence_id, authn_user.user_id, async function (job) {
                sync_result = await syncFromDisk.syncDiskToSqlAsync(inserted_course.path, inserted_course.id, job);
            });

            /* If we have chunks enabled, then create associated chunks for the new course */
            if (config.chunksGenerator) {
                await module.exports._runJobAsync({
                    'type': 'load_chunks',
                    'description': 'Create course chunks',
                    'last_in_sequence': true,
                }, job_sequence_id, authn_user.user_id, async () => {
                    await chunks.updateChunksForCourse({
                        'coursePath': inserted_course.path,
                        'courseId': inserted_course.id,
                        'courseData': sync_result.courseData,
                    });
                });
            }
        };

        /* Create a server job to wrap the course creation process */
        serverJobs.createJobSequence({
            user_id: authn_user.user_id,
            authn_user_id: authn_user.user_id,
            type: 'create_course_repo',
            description: 'Create course repository from request',
            course_request_id: options.course_request_id,
        }, async (err, job_sequence_id) => {
            if (ERR(err, callback)) return;
            callback(null, job_sequence_id);

            try {
                await worker_function(job_sequence_id);
                await sqldb.queryAsync(sql.set_course_request_status, { 'status': 'approved', 'course_request_id': options.course_request_id });
            } catch (err) {
                await sqldb.queryAsync(sql.set_course_request_status, { 'status': 'failed', 'course_request_id': options.course_request_id });
                opsbot.sendCourseRequestMessage(
                    `*Failed to create course "${options.short_name}"*\n\n` +
                    '```\n' +
                    `${err.message.trim()}\n` +
                    '```', (err) => {
                        ERR(err, () => {logger.error(err);});
                    });
            }
        });
    },
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-assessment.html">assessment</a></li><li><a href="module-question.html">question</a></li><li><a href="module-question-servers.html">question-servers</a></li></ul><h3>Classes</h3><ul><li><a href="LocalCache.html">LocalCache</a></li><li><a href="LocalLock.html">LocalLock</a></li><li><a href="module-question-NoSubmissionError.html">NoSubmissionError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_generateAllChunksForCourseListWithJobSequence">_generateAllChunksForCourseListWithJobSequence</a></li><li><a href="global.html#_generateAllChunksForCourseWithJob">_generateAllChunksForCourseWithJob</a></li><li><a href="global.html#_getLock">_getLock</a></li><li><a href="global.html#_syncDiskToSqlWithLock">_syncDiskToSqlWithLock</a></li><li><a href="global.html#_updateScoreWithClient">_updateScoreWithClient</a></li><li><a href="global.html#addError">addError</a></li><li><a href="global.html#addErrors">addErrors</a></li><li><a href="global.html#addWarning">addWarning</a></li><li><a href="global.html#addWarnings">addWarnings</a></li><li><a href="global.html#assetPath">assetPath</a></li><li><a href="global.html#buildDirectory">buildDirectory</a></li><li><a href="global.html#checkAllowAccessDates">checkAllowAccessDates</a></li><li><a href="global.html#checkDuplicateUUIDs">checkDuplicateUUIDs</a></li><li><a href="global.html#close">close</a></li><li><a href="global.html#courseDataHasErrors">courseDataHasErrors</a></li><li><a href="global.html#courseDataHasErrorsOrWarnings">courseDataHasErrorsOrWarnings</a></li><li><a href="global.html#createAndUploadChunks">createAndUploadChunks</a></li><li><a href="global.html#delete">delete</a></li><li><a href="global.html#deleteFromS3Async">deleteFromS3Async</a></li><li><a href="global.html#describe">describe</a></li><li><a href="global.html#downloadFromS3Async">downloadFromS3Async</a></li><li><a href="global.html#ensureChunk">ensureChunk</a></li><li><a href="global.html#ensureChunksForCourseAsync">ensureChunksForCourseAsync</a></li><li><a href="global.html#ERR">ERR</a></li><li><a href="global.html#extractAndSaveCSRFToken">extractAndSaveCSRFToken</a></li><li><a href="global.html#extractAndSaveVariantId">extractAndSaveVariantId</a></li><li><a href="global.html#fetchCheerio">fetchCheerio</a></li><li><a href="global.html#generateAllChunksForCourseList">generateAllChunksForCourseList</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAllChunksForCourse">getAllChunksForCourse</a></li><li><a href="global.html#getChunksDirectoriesForCourseId">getChunksDirectoriesForCourseId</a></li><li><a href="global.html#getDetailsForFile">getDetailsForFile</a></li><li><a href="global.html#getDevHostJobDirectory">getDevHostJobDirectory</a></li><li><a href="global.html#getDevJobDirectory">getDevJobDirectory</a></li><li><a href="global.html#getErrorsAndWarningsForFilePath">getErrorsAndWarningsForFilePath</a></li><li><a href="global.html#getFromS3Async">getFromS3Async</a></li><li><a href="global.html#getJobDirectory">getJobDirectory</a></li><li><a href="global.html#getJobSequenceWithFormattedOutput">getJobSequenceWithFormattedOutput</a></li><li><a href="global.html#getOrUpdateCourseCommitHash">getOrUpdateCourseCommitHash</a></li><li><a href="global.html#getRuntimeDirectoryForCourse">getRuntimeDirectoryForCourse</a></li><li><a href="global.html#getStream">getStream</a></li><li><a href="global.html#getTemplateQuestionIdsAsync">getTemplateQuestionIdsAsync</a></li><li><a href="global.html#hasErrors">hasErrors</a></li><li><a href="global.html#hasErrorsOrWarnings">hasErrorsOrWarnings</a></li><li><a href="global.html#hasUuid">hasUuid</a></li><li><a href="global.html#hasWarnings">hasWarnings</a></li><li><a href="global.html#identifyChangedFiles">identifyChangedFiles</a></li><li><a href="global.html#identifyChunksFromChangedFiles">identifyChunksFromChangedFiles</a></li><li><a href="global.html#identifyChunksToGenerate">identifyChunksToGenerate</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#loadAndValidateJson">loadAndValidateJson</a></li><li><a href="global.html#loadAssessments">loadAssessments</a></li><li><a href="global.html#loadConfigSecrets">loadConfigSecrets</a></li><li><a href="global.html#loadCourseInfo">loadCourseInfo</a></li><li><a href="global.html#loadCourseInstances">loadCourseInstances</a></li><li><a href="global.html#loadFullCourse">loadFullCourse</a></li><li><a href="global.html#loadFullCourseNew">loadFullCourseNew</a></li><li><a href="global.html#loadInfoFile">loadInfoFile</a></li><li><a href="global.html#loadInfoForDirectory">loadInfoForDirectory</a></li><li><a href="global.html#loadQuestions">loadQuestions</a></li><li><a href="global.html#makeError">makeError</a></li><li><a href="global.html#makeGradingResult">makeGradingResult</a></li><li><a href="global.html#makeWarning">makeWarning</a></li><li><a href="global.html#nodeModulesAssetPath">nodeModulesAssetPath</a></li><li><a href="global.html#nonblockingStringify">nonblockingStringify</a></li><li><a href="global.html#pendingChunksMap">pendingChunksMap</a></li><li><a href="global.html#RandomGenerator">RandomGenerator</a></li><li><a href="global.html#readInfoJSON">readInfoJSON</a></li><li><a href="global.html#readJSON">readJSON</a></li><li><a href="global.html#readJSONSyncOrDie">readJSONSyncOrDie</a></li><li><a href="global.html#releaseLock">releaseLock</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#sendCourseRequestMessage">sendCourseRequestMessage</a></li><li><a href="global.html#sendProctorMessage">sendProctorMessage</a></li><li><a href="global.html#sendSlackAlmaMessage">sendSlackAlmaMessage</a></li><li><a href="global.html#Stringifier">Stringifier</a></li><li><a href="global.html#stringifyErrors">stringifyErrors</a></li><li><a href="global.html#stringifyWarnings">stringifyWarnings</a></li><li><a href="global.html#syncDiskToSql">syncDiskToSql</a></li><li><a href="global.html#syncDiskToSqlWithLock">syncDiskToSqlWithLock</a></li><li><a href="global.html#syncOrCreateDiskToSql">syncOrCreateDiskToSql</a></li><li><a href="global.html#tryLock">tryLock</a></li><li><a href="global.html#updateChunksForCourse">updateChunksForCourse</a></li><li><a href="global.html#updateCourseCommitHash">updateCourseCommitHash</a></li><li><a href="global.html#updateScore">updateScore</a></li><li><a href="global.html#upload">upload</a></li><li><a href="global.html#uploadDirectoryToS3Async">uploadDirectoryToS3Async</a></li><li><a href="global.html#uploadToS3Async">uploadToS3Async</a></li><li><a href="global.html#validateAssessment">validateAssessment</a></li><li><a href="global.html#validateCourseInstance">validateCourseInstance</a></li><li><a href="global.html#validateJSON">validateJSON</a></li><li><a href="global.html#validateJSONAsync">validateJSONAsync</a></li><li><a href="global.html#validateOptions">validateOptions</a></li><li><a href="global.html#validateQuestion">validateQuestion</a></li><li><a href="global.html#visitMathBlock">visitMathBlock</a></li><li><a href="global.html#waitLock">waitLock</a></li><li><a href="global.html#writeErrorsAndWarningsForCourseData">writeErrorsAndWarningsForCourseData</a></li><li><a href="global.html#writeErrorsAndWarningsForInfoFileIfNeeded">writeErrorsAndWarningsForInfoFileIfNeeded</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Jun 02 2021 10:45:55 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
