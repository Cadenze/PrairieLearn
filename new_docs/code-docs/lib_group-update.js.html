<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/group-update.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/group-update.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const ERR = require('async-stacktrace');
const _ = require('lodash');
const streamifier = require('streamifier');
const csvtojson = require('csvtojson');
const namedLocks = require('../lib/named-locks');

const logger = require('./logger');
const serverJobs = require('./server-jobs');
const error = require('@prairielearn/prairielib/error');
const sqldb = require('@prairielearn/prairielib/sql-db');
const sqlLoader = require('@prairielearn/prairielib/sql-loader');

const sql = sqlLoader.loadSqlEquiv(__filename);

module.exports = {
    /**
     * Update groups from a CSV file.
     *
     * @param {number} assessment_id - The assessment to update.
     * @param {object} csvFile - An object with keys {originalname, size, buffer}.
     * @param {number} user_id - The current user performing the update.
     * @param {number} authn_user_id - The current authenticated user.
     * @param {function} callback - A callback(err, job_sequence_id) function.
     */
    uploadInstanceGroups(assessment_id, csvFile, user_id, authn_user_id, callback) {
        if (csvFile == null) {
            return callback(new Error('No CSV file uploaded'));
        }
        let params = {assessment_id};
        sqldb.queryOneRow(sql.select_assessment_info, params, function(err, result) {
            if (ERR(err, callback)) return;
            const assessmentLabel = result.rows[0].assessmentLabel;
            const course_instance_id = result.rows[0].course_instance_id;
            const course_id = result.rows[0].course_id;
            const options = {
                course_id: course_id,
                course_instance_id: course_instance_id,
                assessment_id: assessment_id,
                user_id: user_id,
                authn_user_id: authn_user_id,
                type: 'upload_groups',
                description: `Upload group settings for ${assessmentLabel}`,
            };
            //create a job page to display progress and error message
            serverJobs.createJobSequence(options, function(err, job_sequence_id) {
                if (ERR(err, callback)) return;
                callback(null, job_sequence_id);
                const jobOptions = {
                    course_id: course_id,
                    course_instance_id: course_instance_id,
                    assessment_id: assessment_id,
                    user_id: user_id,
                    authn_user_id: authn_user_id,
                    type: 'upload_groups',
                    description: 'Upload group settings for ' + assessmentLabel,
                    job_sequence_id: job_sequence_id,
                    last_in_sequence: true,
                };
                serverJobs.createJob(jobOptions, function(err, job) {
                    if (err) {
                        logger.error('Error in createJob()', err);
                        serverJobs.failJobSequence(job_sequence_id);
                        return;
                    }
                    //create a lock to prevent two instructors from changing the same group assessement at the same time
                    const lockName = 'grouping assessment_id ' + assessment_id;
                    job.verbose(`Trying lock ${lockName}`);
                    namedLocks.tryLock(lockName, (err, lock) => {
                        if (err || lock == null) {
                            job.verbose(`Did not acquire lock ${lockName}`);
                            job.fail(`Another user is already modifying group setting for this assessment. Please try again later.`);
                            return;
                        } else {
                            job.verbose(`Acquired lock ${lockName}`);
                            job.verbose('Uploading group settings for ' + assessmentLabel);
                            job.verbose(`Parsing uploaded CSV file "${csvFile.originalname}" (${csvFile.size} bytes)`);
                            job.verbose(`----------------------------------------`);
                            job.verbose(`Processing group updates...`);
                            const csvStream = streamifier.createReadStream(csvFile.buffer, {encoding: 'utf8'});
                            const csvConverter = csvtojson({
                                colParser:{
                                    groupname: 'string',
                                    groupName: 'string',
                                    uid: 'string',
                                    UID: 'string',
                                    Uid: 'string',
                                },
                                maxRowLength: 10000,
                            });
                            let updateList = new Array();
                            csvConverter
                                .fromStream(csvStream)
                                .subscribe((json) => {
                                    let groupName = json.groupName || json.groupname || null;
                                    let uid = json.uid || json.UID || json.Uid || null;
                                    updateList.push([groupName, uid]);
                                })
                                .then(() => {
                                    let params = [
                                        assessment_id,
                                        updateList,
                                        authn_user_id,
                                    ];
                                    sqldb.callAsync('assessment_groups_update', params, (err, result) => {
                                        const allCount = updateList.length;
                                        let successCount = 0, errorCount = 0;
                                        if (err) {
                                            job.verbose(String(err)); //server error
                                            errorCount = allCount; //all failed
                                        } else {
                                            const notExist = result.rows[0].not_exist_user;
                                            const inGroup = result.rows[0].already_in_group;
                                            if (notExist) {
                                                job.verbose(`----------------------------------------`);
                                                job.verbose(`ERROR: The following users do not exist. Please check their uids first.`);
                                                notExist.forEach(user => {
                                                    job.verbose(user);
                                                });
                                                errorCount += notExist.length;
                                            }
                                            if (inGroup) {
                                                job.verbose(`----------------------------------------`);
                                                job.verbose(`ERROR: The following users are already in a group.`);
                                                inGroup.forEach(user => {
                                                    job.verbose(user);
                                                });
                                                errorCount += inGroup.length;
                                            }
                                            successCount = allCount - errorCount;
                                        }
                                        job.verbose(`----------------------------------------`);
                                        namedLocks.releaseLock(lock, (lockErr) => {
                                            if (lockErr) {
                                                job.fail(`ERROR: The lock ${lockName} was not released successfully`);
                                                return;
                                            }
                                        });
                                        job.verbose(`Released lock ${lockName}`);
                                        if (errorCount == 0) {
                                            job.verbose(`Successfully updated groups for ${successCount} students, with no errors`);
                                            job.succeed();
                                        } else {
                                            job.verbose(`Successfully updated groups for ${successCount} students`);
                                            job.fail(`Error updating ${errorCount} students`);
                                        }
                                    });
                                })
                                .catch((err) => {
                                    job.fail(error.newMessage(err, 'Error processing CSV'));
                                });        
                        }
                    });
                });
            });
        });
    },

    /**
     * Auto generate group settings from input
     *
     * @param {number} assessment_id - The assessment to update.
     * @param {number} user_id - The current user performing the update.
     * @param {number} authn_user_id - The current authenticated user.
     * @param {number} max_group_size - max size of the group
     * @param {number} min_group_size - min size of the group
     * @param {number} option - auto generating mode
     * @param {function} callback - A callback(err, job_sequence_id) function.
     */
    autoGroups(assessment_id, user_id, authn_user_id, max_group_size, min_group_size, option, callback) {
        if (max_group_size &lt; 2 || min_group_size &lt; 1 || max_group_size &lt; min_group_size) {
            return callback(new Error('Group Setting Requirements: max > 1; min > 0; max >= min'));
        }
        let params = {assessment_id};
        sqldb.queryOneRow(sql.select_assessment_info, params, function(err, result) {
            if (ERR(err, callback)) return;
            const assessmentLabel = result.rows[0].assessmentLabel;
            const course_instance_id = result.rows[0].course_instance_id;
            const course_id = result.rows[0].course_id;
            
            const options = {
                course_id: course_id,
                course_instance_id: course_instance_id,
                assessment_id: assessment_id,
                user_id: user_id,
                authn_user_id: authn_user_id,
                type: 'auto_generate_groups',
                description: 'Auto generate group settings for ' + assessmentLabel,
            };
            serverJobs.createJobSequence(options, function(err, job_sequence_id) {
                if (ERR(err, callback)) return;
                callback(null, job_sequence_id);

                const jobOptions = {
                    course_id: course_id,
                    course_instance_id: course_instance_id,
                    assessment_id: assessment_id,
                    user_id: user_id,
                    authn_user_id: authn_user_id,
                    type: 'auto_generate_groups',
                    description: 'Auto generate group settings for ' + assessmentLabel,
                    job_sequence_id: job_sequence_id,
                    last_in_sequence: true,
                };
                serverJobs.createJob(jobOptions, function(err, job) {
                    if (err) {
                        logger.error('Error in createJob()', err);
                        serverJobs.failJobSequence(job_sequence_id);
                        return;
                    }
                    const lockName = 'grouping assessment_id ' + assessment_id;
                    job.verbose(`Trying lock ${lockName}`);
                    namedLocks.tryLock(lockName, (err, lock) => {
                        if (err || lock == null) {
                            job.verbose(`Did not acquire lock ${lockName}`);
                            job.fail(`Another user is already modifying group setting for this assessment. Please try again later.`);
                            return;
                        } else {
                            job.verbose(`Acquired lock ${lockName}`);
                            job.verbose('Uploading group settings for ' + assessmentLabel);

                            (async () => {
                                try {
                                    job.verbose('Auto generate group settings for ' + assessmentLabel);
                                    job.verbose(`----------------------------------------`);
                                    job.verbose(`Fetching the enrollment lists...`);
                                    const aid = {assessment_id};
                                    const students = [];
                                    const resultList = await sqldb.queryAsync(sql.select_enrollments, aid);
                                    resultList.rows.forEach(element => {
                                        students.push(element.user_list);
                                    });
                                    _.shuffle(students);
                                    var numStudents = resultList.rowCount;
                                    var notAssigned = [];
                                    const resultList2 = await sqldb.queryAsync(sql.select_not_assigned, aid);
                                    resultList2.rows.forEach(element => {
                                        notAssigned.push(element.user_list);
                                    });
                                    _.shuffle(notAssigned);
                                    var numNotAssigned = resultList2.rowCount;
                                    job.verbose(`There are ` + numStudents + ' students enrolled in ' + assessmentLabel);
                                    job.verbose(numNotAssigned + ' of them have not been in a group');
                                    job.verbose(`----------------------------------------`);
                                    job.verbose(`Processing creating groups - max of ` + max_group_size + ' and min of ' + min_group_size);
                                    let numGroup = Math.ceil(numStudents / max_group_size);
                                    let updateList = new Array();
                                    // fill in the updateList with groupname and uid
                                    for (let i = 0; i &lt; numGroup; i++) {
                                        let groupName = 'group' + i;
                                        for (let j = 0; j &lt; max_group_size; j++) {
                                            if (students.length > 0) {
                                                let uid = students.pop();
                                                updateList.push([groupName, uid]);
                                            }
                                        }
                                    }
                                    let params = [
                                        assessment_id,
                                        updateList,
                                        authn_user_id,
                                    ];
                                    sqldb.callAsync('assessment_groups_update', params, (err, result) => {
                                        const allCount = updateList.length;
                                        let successCount = 0, errorCount = 0;
                                        if (err) {
                                            job.verbose(String(err)); //server error
                                            errorCount = allCount; //all failed
                                        } else {
                                            const notExist = result.rows[0].not_exist_user;
                                            const inGroup = result.rows[0].already_in_group;
                                            if (notExist) {
                                                job.verbose(`----------------------------------------`);
                                                job.verbose(`ERROR: The following users do not exist. Please check their uids first.`);
                                                notExist.forEach(user => {
                                                    job.verbose(user);
                                                });
                                                errorCount += notExist.length;
                                            }
                                            if (inGroup) {
                                                job.verbose(`----------------------------------------`);
                                                job.verbose(`ERROR: The following users are already in a group.`);
                                                inGroup.forEach(user => {
                                                    job.verbose(user);
                                                });
                                                errorCount += inGroup.length;
                                            }
                                            successCount = allCount - errorCount;
                                        }
                                        job.verbose(`----------------------------------------`);
                                        namedLocks.releaseLock(lock, (lockErr) => {
                                            if (lockErr) {
                                                job.fail(`ERROR: The lock ${lockName} was not released successfully`);
                                                return;
                                            }
                                        });
                                        job.verbose(`Released lock ${lockName}`);
                                        if (errorCount == 0) {
                                            job.verbose(`Successfully updated groups for ${successCount} students, with no errors`);
                                            job.succeed();
                                        } else {
                                            job.verbose(`Successfully updated groups for ${successCount} students`);
                                            job.fail(`Error updating ${errorCount} students`);
                                        }
                                    });
                                } catch (err){
                                    logger.error('Error while creating groups', err);
                                    serverJobs.failJobSequence(job_sequence_id);
                                } 
                            })();
                        }
                    });
                });
            });
        });
    },
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-assessment.html">assessment</a></li><li><a href="module-question.html">question</a></li><li><a href="module-question-servers.html">question-servers</a></li></ul><h3>Classes</h3><ul><li><a href="LocalCache.html">LocalCache</a></li><li><a href="LocalLock.html">LocalLock</a></li><li><a href="module-question-NoSubmissionError.html">NoSubmissionError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_generateAllChunksForCourseListWithJobSequence">_generateAllChunksForCourseListWithJobSequence</a></li><li><a href="global.html#_generateAllChunksForCourseWithJob">_generateAllChunksForCourseWithJob</a></li><li><a href="global.html#_getLock">_getLock</a></li><li><a href="global.html#_syncDiskToSqlWithLock">_syncDiskToSqlWithLock</a></li><li><a href="global.html#_updateScoreWithClient">_updateScoreWithClient</a></li><li><a href="global.html#addError">addError</a></li><li><a href="global.html#addErrors">addErrors</a></li><li><a href="global.html#addWarning">addWarning</a></li><li><a href="global.html#addWarnings">addWarnings</a></li><li><a href="global.html#assetPath">assetPath</a></li><li><a href="global.html#buildDirectory">buildDirectory</a></li><li><a href="global.html#checkAllowAccessDates">checkAllowAccessDates</a></li><li><a href="global.html#checkDuplicateUUIDs">checkDuplicateUUIDs</a></li><li><a href="global.html#close">close</a></li><li><a href="global.html#courseDataHasErrors">courseDataHasErrors</a></li><li><a href="global.html#courseDataHasErrorsOrWarnings">courseDataHasErrorsOrWarnings</a></li><li><a href="global.html#createAndUploadChunks">createAndUploadChunks</a></li><li><a href="global.html#delete">delete</a></li><li><a href="global.html#deleteFromS3Async">deleteFromS3Async</a></li><li><a href="global.html#describe">describe</a></li><li><a href="global.html#downloadFromS3Async">downloadFromS3Async</a></li><li><a href="global.html#ensureChunk">ensureChunk</a></li><li><a href="global.html#ensureChunksForCourseAsync">ensureChunksForCourseAsync</a></li><li><a href="global.html#ERR">ERR</a></li><li><a href="global.html#extractAndSaveCSRFToken">extractAndSaveCSRFToken</a></li><li><a href="global.html#extractAndSaveVariantId">extractAndSaveVariantId</a></li><li><a href="global.html#fetchCheerio">fetchCheerio</a></li><li><a href="global.html#generateAllChunksForCourseList">generateAllChunksForCourseList</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAllChunksForCourse">getAllChunksForCourse</a></li><li><a href="global.html#getChunksDirectoriesForCourseId">getChunksDirectoriesForCourseId</a></li><li><a href="global.html#getDetailsForFile">getDetailsForFile</a></li><li><a href="global.html#getDevHostJobDirectory">getDevHostJobDirectory</a></li><li><a href="global.html#getDevJobDirectory">getDevJobDirectory</a></li><li><a href="global.html#getErrorsAndWarningsForFilePath">getErrorsAndWarningsForFilePath</a></li><li><a href="global.html#getFromS3Async">getFromS3Async</a></li><li><a href="global.html#getJobDirectory">getJobDirectory</a></li><li><a href="global.html#getJobSequenceWithFormattedOutput">getJobSequenceWithFormattedOutput</a></li><li><a href="global.html#getOrUpdateCourseCommitHash">getOrUpdateCourseCommitHash</a></li><li><a href="global.html#getRuntimeDirectoryForCourse">getRuntimeDirectoryForCourse</a></li><li><a href="global.html#getStream">getStream</a></li><li><a href="global.html#getTemplateQuestionIdsAsync">getTemplateQuestionIdsAsync</a></li><li><a href="global.html#hasErrors">hasErrors</a></li><li><a href="global.html#hasErrorsOrWarnings">hasErrorsOrWarnings</a></li><li><a href="global.html#hasUuid">hasUuid</a></li><li><a href="global.html#hasWarnings">hasWarnings</a></li><li><a href="global.html#identifyChangedFiles">identifyChangedFiles</a></li><li><a href="global.html#identifyChunksFromChangedFiles">identifyChunksFromChangedFiles</a></li><li><a href="global.html#identifyChunksToGenerate">identifyChunksToGenerate</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#loadAndValidateJson">loadAndValidateJson</a></li><li><a href="global.html#loadAssessments">loadAssessments</a></li><li><a href="global.html#loadConfigSecrets">loadConfigSecrets</a></li><li><a href="global.html#loadCourseInfo">loadCourseInfo</a></li><li><a href="global.html#loadCourseInstances">loadCourseInstances</a></li><li><a href="global.html#loadFullCourse">loadFullCourse</a></li><li><a href="global.html#loadFullCourseNew">loadFullCourseNew</a></li><li><a href="global.html#loadInfoFile">loadInfoFile</a></li><li><a href="global.html#loadInfoForDirectory">loadInfoForDirectory</a></li><li><a href="global.html#loadQuestions">loadQuestions</a></li><li><a href="global.html#makeError">makeError</a></li><li><a href="global.html#makeGradingResult">makeGradingResult</a></li><li><a href="global.html#makeWarning">makeWarning</a></li><li><a href="global.html#nodeModulesAssetPath">nodeModulesAssetPath</a></li><li><a href="global.html#nonblockingStringify">nonblockingStringify</a></li><li><a href="global.html#pendingChunksMap">pendingChunksMap</a></li><li><a href="global.html#RandomGenerator">RandomGenerator</a></li><li><a href="global.html#readInfoJSON">readInfoJSON</a></li><li><a href="global.html#readJSON">readJSON</a></li><li><a href="global.html#readJSONSyncOrDie">readJSONSyncOrDie</a></li><li><a href="global.html#releaseLock">releaseLock</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#sendCourseRequestMessage">sendCourseRequestMessage</a></li><li><a href="global.html#sendProctorMessage">sendProctorMessage</a></li><li><a href="global.html#sendSlackAlmaMessage">sendSlackAlmaMessage</a></li><li><a href="global.html#Stringifier">Stringifier</a></li><li><a href="global.html#stringifyErrors">stringifyErrors</a></li><li><a href="global.html#stringifyWarnings">stringifyWarnings</a></li><li><a href="global.html#syncDiskToSql">syncDiskToSql</a></li><li><a href="global.html#syncDiskToSqlWithLock">syncDiskToSqlWithLock</a></li><li><a href="global.html#syncOrCreateDiskToSql">syncOrCreateDiskToSql</a></li><li><a href="global.html#tryLock">tryLock</a></li><li><a href="global.html#updateChunksForCourse">updateChunksForCourse</a></li><li><a href="global.html#updateCourseCommitHash">updateCourseCommitHash</a></li><li><a href="global.html#updateScore">updateScore</a></li><li><a href="global.html#upload">upload</a></li><li><a href="global.html#uploadDirectoryToS3Async">uploadDirectoryToS3Async</a></li><li><a href="global.html#uploadToS3Async">uploadToS3Async</a></li><li><a href="global.html#validateAssessment">validateAssessment</a></li><li><a href="global.html#validateCourseInstance">validateCourseInstance</a></li><li><a href="global.html#validateJSON">validateJSON</a></li><li><a href="global.html#validateJSONAsync">validateJSONAsync</a></li><li><a href="global.html#validateOptions">validateOptions</a></li><li><a href="global.html#validateQuestion">validateQuestion</a></li><li><a href="global.html#visitMathBlock">visitMathBlock</a></li><li><a href="global.html#waitLock">waitLock</a></li><li><a href="global.html#writeErrorsAndWarningsForCourseData">writeErrorsAndWarningsForCourseData</a></li><li><a href="global.html#writeErrorsAndWarningsForInfoFileIfNeeded">writeErrorsAndWarningsForInfoFileIfNeeded</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Jun 02 2021 10:45:55 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
